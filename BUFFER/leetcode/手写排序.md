# 快速排序
### 注意此写法~~不能适用于快速选择~~（可以适用，但是pivot的位置并不是固定的，要在l == r时才能确定结果），因为pivot的位置不是确定的。

**记住递归的边界，这个算法是不会排除pivot的，只能是根据pivot的值左右分开[l,j]  [j+1,r]**
wiki里的选择过不了leetcode，因为交换次数太多了，按照左右两边同时扩展，能将交换次数减少。
```java
// [l, r]
void quick_sort(int[] nums, int l, int r) {
	if (l == r) return;
	int x = nums[l], i = l-1, j = r+1;
	while (i < j) {  // 红蓝染色，此时i,j是已经排好序的第一个元素
		do ++i; while (nums[i] < x); 
		do --j; while (nums[j] > x);

		if (i < j) { // 红蓝染色，此时i,j是排好序的下一个元素
			int tmp = nums[i];
			nums[i] = nums[j];
			nums[j] = tmp;
		}
	}

	// [l,j]  [j+1,r]
	quick_sort(nums, l, j);
	quick_sort(nums, j+1, r);
}
```
# 归并排序
```java
// [l, r]
merge_sort(int[] nums, int l, int r) {
	if (l == r) return;
	int mid = l + r >> 1;
	merge_sort(nums, l, mid);
	merge_sort(nums, mid+1, r);

	int[] tmp = new int[r-l+1];
	int i = l, j = mid+1, k = 0;
	while (i <= mid && j <= r) {
		if (nums[i] < nums[j]) tmp[k++] = nums[i++];
		else tmp[k++] = nums[j++];
	}
	while (i <= mid) tmp[k++] = nums[i++];
	while (j <= r) tmp[k++] = nums[j++];

	for (int m = 0, n = l; m <= r-l; m++) nums[n++] = tmp[m];
}
```
# 冒泡排序
```java
bubble_sort(int[] nums, int l, int r) {
	for (int i = l; i < r; i++) {
		for (int j = l; j < r - i; j++) {
			if (nums[j] > nums[j+1]) {
				int tmp = nums[j];
				nums[j] = nums[j+1];
				nums[j+1] = tmp;
			}
		}
	}
}
```
