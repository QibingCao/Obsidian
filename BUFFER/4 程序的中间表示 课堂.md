---

类型: 笔记
创建日期: 2024-05-28
修改日期: 2024-05-28
---
大部分程序的处理对象是数据，但是编译器的对象是程序，是一种自指向。

## 程序的中间表示 IR
### 架构
编译器是标准的流水线架构
#### 为什么需要中间表示？
为什么现代流水线变得越来越长，好几个中端。
1. 减小前后端之间的语义差距。c语言可以很好的对应到相应的机器程序，但是对于js类似的代码，完全无法对应机器代码。好的方面是抽象程度高，更接近问题本质，但是越来越脱离底层。
2. 工程量。多语言多后端。gcc支持c，cpp等语言输入，x86，RISCV等输出。有多输入多输出的需求，所以要设计一个统一的中间表示。M * N 到 M + N
3. 艺术。人类到目前为止对编程的本质还不是很清楚。这也是编程语言还没大一统的原因。（笑 
#### 分类
三地址码 TAC
控制流图 CFG
字节码 ByteCode（栈式计算机）
栈式计算机，操作数栈，所有的操作数都在栈上。性能不好，但是生成代码容易。虚拟机一般都是栈式计算机。
静态单赋值 SSA
程序依赖图 PDG
延续传递形式 CPS
类型化的中间语言 TIL
...
为什么有这么多中间表示。不同角度看待中间表示，就是不同的编程语言。比如写call back式的语言就是在手写CPS。
## 三地址码 TAC
Slp
```
e ::= n | x | e + e | e / e
S ::= x = e | print(e) | S; S | if(e, S1, S2)
```
x = 3+4+5，可以表示为一棵树。Slp可以通过递归构建无限高度的树
TAC（在一个典型的表达式中最多出现三个操作数）也叫四元式（Quarter Tuple）{op x y z}。
```
e ::= x | n | x + y | x ? y
S ::= x = e | print(x) | S; S | L | if(x, L, L) | jmp L
```
TAC中没有递归，写不出上面的多加号的表达式，换句话说TAC生成的树有最大高度。TAC模仿了现代的RISC架构，在无限寄存器条件下。
#### 翻译算法 AST -> TAC
递归下降算法，标准的树的后序遍历。维持一个清晰的不变式（就算法导论证明中的不变式）
```
trans(e) = return x;           x =e
		   
		   x = newID()        x = n
		   "x = n"（向某个地方发射代码使其持久化
		   ）
			return x;

			x1 = trans(e1)     x = e1 + e2
			x2 = trans(e2)
			"x = x1 + x2"
			return x

			返回值都是Id（变量）代表这个元素在那个寄存器存储

trans_S(S(if(e, S1, S2))):
			x = trans(e)
			"if(x, L1, L2)"
		"L1"
			trans_S(S1)
			"jmp L3"
		"L2"
			trans_S(S2)
			"jmp L3"
			...
```
递归下降可以将任何一颗树递归后序遍历。
其实可以和lab2合起来一次遍历，但是两次遍历更符合人的思维，更不容易出错（lab2已经保证树的构建是正确的）

## 控制流图CFG
```
if(x)
	y = 3
else 
	y = 4
```
```
if (x, L1, L2)          ->  基本快
---------------------
L1:
	y = 3
	jmp L
---------------------
L2:
	y = 4
	jmp L4
---------------------
L3:


```
把一个线性结构的三地址码，做了分块结构
#### 基本块
	名字（唯一）
	语句序列（0-n）
	唯一的跳转
为什么要基本块？
基本块内顺序执行，数学概念：线性序（与之相对的：偏序，拓扑序）
不能从中间退出
不能跳到块中间执行
##### 基本块数据结构
```
b ::= L S* j
S ::= x = e | print(x) ...
j ::= if (x, L, L) | jmp L | throw x | 
```
计算机科学没有魔法，只有分类（笑
## CFG 生成
### A1 自底向上 Bottom up
处理的东西没有很明确的块状结构。
c是一个著名的臭名昭著的非结构化底层程序语言。它本身就允许goto这种机制。
```
语法树 -> 线性代码（不一定是必需的，有时候直接就是二进制代码，得逆向）
起始语句（leader） （寻找块第一条语句）归纳法：jmp地址是leader，jmp下一句是leader。。。
顺序扫描 -> 基本块
```
很像CSAPP中lab2的bomblab阅读汇编代码，想要搞清代码结构

### A2 自顶向下 Top down
java就是一个很结构化的语言。
维护一个current block指针，自顶向下填充代码块
## 死代码消除
在CFG图中，死代码块没有边指向它。只需要DFS，没被visit过的就是。
so easy


## 面向对象语言
（讲述内容会偏向我们的实验）
OOP -> 命令式
minijava 没有动态特性，没有反射没有异常处理等等

毫无技术含量，所谓的设计模式也没啥含量，代码复杂性

什么是类?
Fuction Closing
给函数加个this参数，就变成了类内的方法

写一个结构体，用this指针指向，没有任何区别（只有类，对象，方法（没有继承
)）。


继承的实现：
前缀法，把父类的字段全部拷过来，方法也都拷过来

虚函数和重载
虚函数表
n个方法指向n个方法的指针
虚函数：子类和父类相同的方法，子类覆盖父类，虚函数表项的覆盖


向下塑性
父类指针可以指向子类