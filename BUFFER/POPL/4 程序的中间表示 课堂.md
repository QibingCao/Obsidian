---

类型: 笔记
创建日期: 2024-05-28
修改日期: 2024-05-28
---
大部分程序的处理对象是数据，但是编译器的对象是程序，是一种自指向。

## 程序的中间表示 IR
### 架构
编译器是标准的流水线架构
#### 为什么需要中间表示？
为什么现代流水线变得越来越长，好几个中端。
1. 减小前后端之间的语义差距。c语言可以很好的对应到相应的机器程序，但是对于js类似的代码，完全无法对应机器代码。好的方面是抽象程度高，更接近问题本质，但是越来越脱离底层。
2. 工程量。多语言多后端。gcc支持c，cpp等语言输入，x86，RISCV等输出。有多输入多输出的需求，所以要设计一个统一的中间表示。M * N 到 M + N
3. 艺术。人类到目前为止对编程的本质还不是很清楚。这也是编程语言还没大一统的原因。（笑 
#### 分类
三地址码 TAC
控制流图 CFG
字节码 ByteCode（栈式计算机）
栈式计算机，操作数栈，所有的操作数都在栈上。性能不好，但是生成代码容易。虚拟机一般都是栈式计算机。
静态单赋值 SSA
程序依赖图 PDG
延续传递形式 CPS
类型化的中间语言 TIL
...
为什么有这么多中间表示。不同角度看待中间表示，就是不同的编程语言。比如写call back式的语言就是在手写CPS。
## 三地址码 TAC
Slp
```
e ::= n | x | e + e | e / e
S ::= x = e | print(e) | S; S | if(e, S1, S2)
```
x = 3+4+5，可以表示为一棵树。Slp可以通过递归构建无限高度的树
TAC（在一个典型的表达式中最多出现三个操作数）也叫四元式（Quarter Tuple）{op x y z}。
```
e ::= x | n | x + y | x ? y
S ::= x = e | print(x) | S; S | L | if(x, L, L) | jmp L
```
TAC中没有递归，写不出上面的多加号的表达式，换句话说TAC生成的树有最大高度。TAC模仿了现代的RISC架构，在无限寄存器条件下。
#### 翻译算法 AST -> TAC
递归下降算法，标准的树的后序遍历。维持一个清晰的不变式（就算法导论证明中的不变式）
```
trans(e) = return x;           x =e
		   
		   x = newID()        x = n
		   "x = n"（向某个地方发射代码使其持久化
		   ）
			return x;

			x1 = trans(e1)     x = e1 + e2
			x2 = trans(e2)
			"x = x1 + x2"
			return x

			返回值都是Id（变量）代表这个元素在那个寄存器存储

trans_S(S(if(e, S1, S2))):
			x = trans(e)
			"if(x, L1, L2)"
		"L1"
			trans_S(S1)
			"jmp L3"
		"L2"
			trans_S(S2)
			"jmp L3"
			...
```
递归下降可以将任何一颗树递归后序遍历。
其实可以和lab2合起来一次遍历，但是两次遍历更符合人的思维，更不容易出错（lab2已经保证树的构建是正确的）

## 控制流图CFG
```
if(x)
	y = 3
else 
	y = 4
```
```
if (x, L1, L2)          ->  基本快
---------------------
L1:
	y = 3
	jmp L
---------------------
L2:
	y = 4
	jmp L4
---------------------
L3:


```
把一个线性结构的三地址码，做了分块结构
#### 基本块
	名字（唯一）
	语句序列（0-n）
	唯一的跳转
为什么要基本块？
基本块内顺序执行，数学概念：线性序（与之相对的：偏序，拓扑序）
不能从中间退出
不能跳到块中间执行
##### 基本块数据结构
```
b ::= L S* j
S ::= x = e | print(x) ...
j ::= if (x, L, L) | jmp L | throw x | 
```
计算机科学没有魔法，只有分类（笑
## CFG 生成
### A1 自底向上 Bottom up
处理的东西没有很明确的块状结构。
c是一个著名的臭名昭著的非结构化底层程序语言。它本身就允许goto这种机制。
```
语法树 -> 线性代码（不一定是必需的，有时候直接就是二进制代码，得逆向）
起始语句（leader） （寻找块第一条语句）归纳法：jmp地址是leader，jmp下一句是leader。。。
顺序扫描 -> 基本块
```
很像CSAPP中lab2的bomblab阅读汇编代码，想要搞清代码结构

### A2 自顶向下 Top down
java就是一个很结构化的语言。
维护一个current block指针，自顶向下填充代码块
## 死代码消除
在CFG图中，死代码块没有边指向它。只需要DFS，没被visit过的就是。
so easy


## 面向对象语言
（讲述内容会偏向我们的实验）
OOP -> 命令式
minijava 没有动态特性，没有反射没有异常处理等等

毫无技术含量，所谓的设计模式也没啥含量，代码复杂性

什么是类?
Fuction Closing
给函数加个this参数，就变成了类内的方法

写一个结构体，用this指针指向，没有任何区别（只有类，对象，方法（没有继承
)）。


继承的实现：
前缀法，把父类的字段全部拷过来，方法也都拷过来

虚函数和重载
虚函数表
n个方法指向n个方法的指针
虚函数：子类和父类相同的方法，子类覆盖父类，虚函数表项的覆盖


向下塑性
父类指针可以指向子类
拷打面向对象

面向对象的本质，动态性

一个对象函数的调用是动态的

一个指向对象的指针，他指向的对象是动态的

所以代码不可推理，不好debug

这样做真的对吗

多继承

变成有向无环图了

之前是线性序

现在没办法排序了

msvc，gcc，clang拓扑排序

也有图着色

单继承加动态性，多继承加静态性

子指针转成父指针

你得去找你的祖先

Java本质上是个动态语言

支持反射，需要在内存中维护一个类的所有信息，需要有一个元信息字段指向这个类

interface实现

非常不漂亮的设计

Java的设计在1993

Java的设计原则，去除cpp的复杂东西，纯面向对象

Java抵不住cop程序员的压力

搞了穷人版的多继承

不要迷信Java

异常处理

早期异常栈

现在异常表

异常是跨函数的，异常表也是全局的
