---

类型: 笔记
创建日期: 2024-08-12
修改日期: 2024-08-12
---
想要拼接多个char * 字符串，可以strcpy，strcat
方便的方式是直接sprintf，自己设定格式拼接起来
```
strcpy(childname, dirname);
strcat(childname, pdirent->d_name);
strcat(childname, "/");
```
`sprintf(childname, "%s%s%s", dirname, "/", pdirent->d_name);`


**//**也可以被视作是根目录（/只起到分割作用），无限个/都无所谓，加就完了
![[Pasted image 20240812162038.png]]


守护进程就是孤儿进程，名字一般以d结尾（daemon）
创建时必须fork一下，因为父进程默认是组长，无法更换session id。子进程单独列一个组，成为孤儿进程之后父进程就是pid=1.这样做daemon就单独新开一个会话，并且是这个会话的后台进程。

mkfifo 1.pipe 有名管道
fork后父子间使用的，没有显示文件的是匿名管道


条件变量
先完成的事情 T1完全走完了，signal也发了，全搞完了
T2才开始执行，此时接收不到T1的signal，陷入永久的等待。



先检查flag是否成立，若不成立再去wait
flag成立说明先前事件已经完全结束
不成立说明还没结束，此时肯定还没执行signal

1. `pthread_cond_wait()`  
    用于阻塞当前线程，等待别的线程使用`pthread_cond_signal()`或`pthread_cond_broadcast`来唤醒它 `pthread_cond_wait()` 必须与`pthread_mutex`配套使用。`pthread_cond_wait()`函数一进入`wait`状态就会自动`release mutex`。当其他线程通过`pthread_cond_signal()`或`pthread_cond_broadcast`，把该线程唤醒，使`pthread_cond_wait()`通过（返回）时，该线程又自动获得该`mutex`。


// 操作系统可能会虚假唤醒，建议所有的wait前面的判断都用while而不是if
        while (share->ticketNum >= 10) {
            pthread_cond_wait(&share->cond, &share->mutex);
        }

man -k
模糊搜索，应该是类似vscode提示词选项那种

进程线程切换差异
### **底层差异**
- **地址空间**：进程切换需要切换页表，涉及大量内存管理相关的操作；而线程切换在同一地址空间中进行，不需要切换页表。
- **资源共享**：进程之间不共享内存和资源，因此需要完整的上下文切换；线程共享大部分资源，因此上下文切换只需处理线程相关的寄存器和堆栈指针等。
- **开销**：进程切换的开销主要来自于切换页表和缓存刷新，而线程切换的开销主要是保存和恢复线程的寄存器状态，因而较低。


![[Pasted image 20240816195834.png]]

![[Pasted image 20240816201240.png]]

![[Pasted image 20240816201258.png]]

既然mac地址硬件唯一的，那互联网为什么不直接用mac地址而是要用ip
##### ChatGPT 说：
1. **网络分层架构**：互联网采用分层协议架构，MAC地址位于数据链路层（第二层），而IP地址位于网络层（第三层）。每一层都有不同的职责。MAC地址用于本地网络内的通信，例如在同一个局域网（LAN）中，设备通过MAC地址互相识别和通信。
    
2. **路由与可扩展性**：MAC地址是平面的，也就是说，MAC地址没有任何结构或层次，而IP地址是分层的，具有网络部分和主机部分。这种分层结构使得路由器能够更高效地处理和转发数据包。如果互联网使用MAC地址，路由器将无法通过简单的地址前缀来确定数据包的目的地，这会导致路由表变得非常庞大且复杂，严重影响网络性能和可扩展性。
    
3. **隐私与安全**：MAC地址是硬件绑定的，在设备的整个生命周期中通常不会改变。如果直接在互联网上使用MAC地址，会导致设备的物理位置和身份容易被追踪，增加隐私和安全风险。IP地址则可以动态分配，通过NAT（网络地址转换）等技术，IP地址可以在不同网络中变化，从而提供一定程度的隐私保护。
    
4. **地址管理**：IP地址的分配是由全球的互联网管理机构（如IANA）和区域性注册机构负责的，具有全球性的协调管理。**而MAC地址则由设备制造商分配管理，只在局部网络中有意义。**在互联网层面，使用IP地址便于网络管理和资源分配。

windows下
arp /a
![[Pasted image 20240816214515.png]]
arp  /d 清理


![[Pasted image 20240816234112.png]]


![[Pasted image 20240817105311.png]]

建立一个连接需要三次握手，而终止一个连接要经过 4次握手。这由T C P的半关闭（h a l f -c l o s e）造成的。既然一个T C P连接是全双工（即数据在两个方向上能同时传递），因此每个方向必须单独地进行关闭。这原则就是当一方完成它的数据发送任务后就能发送一个 F I N来终止这个方向连接。当一端收到一个 F I N，它必须通知应用层另一端几经终止了那个方向的数据传送。发送F I N通常是应用层进行关闭的结果。


全部网络信息
netstat -an
![[Pasted image 20240817113307.png]]

![[Pasted image 20240817130752.png]]![[Pasted image 20240817130806.png]]
![[Pasted image 20240817130821.png]]
![[Pasted image 20240817130832.png]]
真实案例，我在ctrl c 主动断开服务端的连接之后，下次运行报错
![[Pasted image 20240817212910.png]
![[Pasted image 20240817213550.png]]

man inet_addr
查看网络相关函数

### socket 缓冲区
在POSIX系统（如Linux）中，`open` 打开的文件通常是没有缓冲区的，文件的读写操作是直接传递给操作系统内核进行的，不经过用户空间的缓冲区。每次调用 `read` 或 `write` 时，数据会直接从内核态传输到用户态，不会经过额外的用户空间缓冲区。

`socket` 创建的 `socketfd` 通常是有缓冲区的。系统为每个socket分配读缓冲区和写缓冲区。这些缓冲区存在于**内核空间**，用于临时存储发送和接收的数据，以提高网络通信的效率和吞吐量。

- `open` 打开的文件通常**没有**用户空间的缓冲区。
- `socket` 创建的 `socketfd` 通常**有**读缓冲区和写缓冲区，这些缓冲区存在于内核空间。

### sockaddr
- `sockaddr` 是通用的地址结构体，长度为 16 字节。
- `sockaddr_in` 是专门用于 IPv4 地址的结构体，长度为 16 字节。
- `sockaddr_in6` 是用于 IPv6 地址的结构体，长度为 28 字节。
因此，**`sockaddr` 和 `sockaddr_in` 的长度是相同的（16 字节）**，而 **`sockaddr_in6` 的长度不同（28 字节）**。

bind，connect等函数，在传入socket_addr之后还会跟一个socklent_t的长度参数，以解决长度不确定的问题



netstat -an列出全部网络状态
如果出错了，服务端看看自己的网络状态

TCP是流式协议STREAM，跟前面的管道很像
当你用send把好几个数据发送给内核缓冲区时，内核一次性就发给对面了，数据之间没有边界


### 为什么都可以用`select()`进行监听：
`select()`是一个通用的I/O多路复用函数，它能够同时监视多个文件描述符是否可读、可写或有异常事件发生。无论是监听连接请求的fd、普通文件fd，还是已经连接的socket fd，`select()`都能处理，因为它的底层机制是对文件描述符上的事件进行监视。虽然这些fd的用途不同，但它们都可以表现出"可读"或"可写"的状态，这使得`select()`可以通用地处理不同类型的I/O操作。
`bind`过的用于监听的文件描述符（fd）在使用`select()`时，应该放在**读集**（read set）中进行监视。这是因为你希望监视的是该fd上是否有新的连接请求到来，这种情况对应于"可读"状态。


在C语言中，`int netfd[1024] = {-1};` 这种初始化是合法的。这个语法的意思是将数组 `netfd` 的第一个元素初始化为 `-1`，**而其余的元素都初始化为 `0`。**
在C语言中，当你用`{0}`来初始化数组时，第一个元素被显式设置为 `0`，其余的元素也会自动初始化为 `0`。因此，`netfd`数组的1024个元素都会被设置为 `0`。