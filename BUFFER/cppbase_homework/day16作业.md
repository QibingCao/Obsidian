第一题 **智能指针的实现原理是什么？用到了什么技术？该技术有哪些特征？**

> 智能指针的实现原理就是利用对象的生命周期来回收资源。用到了RAII技术，其特点是：
>
> - 在构造函数中初始化资源，或托管资源；
>
> - 在析构函数中释放资源；
>
> - 一般不允许进行复制或者赋值（对象语义）；
>
> - 提供若干访问资源的方法（如：读写文件）。





第二题 **C++提供了哪几种智能指针，其各自的特点是什么？请详细描述**

> auto_ptr:允许复制赋值操作，但实际上是将托管的资源控制权进行转移，因此存在隐患，已被移除。



> unique_ptr是独享所有权的智能指针
>
> 特点1：不允许复制或者赋值，具备对象语义。
>
> 特点2：独享所有权的智能指针
>
> 特点3：作为容器元素，但需要传递unique_ptr的右值作为容器的元素。如果传左值会发生复制，而unique_ptr是不允许复制的。
>



> shared_ptr是共享所有权的智能指针，可以进行复制或赋值，但复制或赋值时，并不是真正拷贝对象，而只是将引用计数加1。
>
> **特征1：共享所有权的智能指针**
>
> 可以使用引用计数记录对象的个数。
>
> **特征2：可以进行复制或者赋值**
>
> 表明具备值语义。
>
> **特征3：也可以作为容器的元素**
>
> 作为容器元素的时候，即可以传递左值，也可以传递右值。（区别于unique_ptr只能传右值）
>
> **特征4：也具备移动语义**
>
> 表明也有移动构造函数与移动赋值函数。



> weak_ptr是弱引用的智能指针，它是shared_ptr的一个补充，使用它进行复制或者赋值时，并不会导致引用计数加1，是为了解决shared_ptr的问题而诞生的。
>
> weak_ptr知道所托管的对象是否还存活，如果存活，必须要提升为shared_ptr才能对资源进行访问，不能直接访问。
>







第三题 **什么是右值引用？C++11为什么要引入右值引用？**

> 右值引用是只能够绑定右值的引用，如int && ref = 1，右值引用不能绑定左值。
>
> 在之前的C++标准下，对象通过一个临时对象（匿名对象）进行复制或赋值操作时，都需要重新开辟空间进行复制。而临时对象所申请的堆空间会马上被销毁，这样做对资源的利用率不高，因此希望复用临时对象申请的堆空间。但不能影响对左值的复制赋值操作（仍要重新开辟空间），因此需要将左值和右值分开。
>
> 有了右值引用后，可以给一个类准备移动构造函数和移动赋值函数，其形参为右值引用。之后对象在进行复制或赋值操作时会先尝试调用移动语义的这两个函数，如果参数是右值，则由它们处理；如果参数是左值，则再去调用复制控制的函数。





第四题 **std::move函数的作用是什么？**

> 在一些使用移动语义的场景下，有时需要将左值转为右值。std::move函数的作用是显式的将一个左值转换为右值，<span style=color:red;background:yellow>**其实现本质上就是一个强制转换**</span>。





第五题 **为采用深拷贝方式实现的String类添加移动构造函数和移动赋值运算符函数，并进行测试。**

String(String &&rhs);
String & operator=(String &&rhs);



``` c++
	//移动构造
    String(String && rhs)
    : _str(rhs._str)
    {
        cout << "String(String&&)" << endl;
        rhs._str = nullptr;
    }

    //移动赋值函数
    String & operator=(String && rhs)
    {
        cout << "String & operator=(String&&)" << endl;
        if(this != &rhs){
            delete [] _str;
            //浅拷贝
            _str = rhs._str;
            rhs._str = nullptr;
        }
        return *this;
    }
```























