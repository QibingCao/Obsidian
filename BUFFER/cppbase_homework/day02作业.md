第一题 

**引用与指针的区别是什么？**

> 引用的底层就是是指针实现的，可以把引用视为一个受限制的指针，与普通的指针有如下区别
>
> 1. 引用必须初始化，指针可以不初始化；
> 2. 引用不能修改绑定，但是指针可以修改指向；
> 3. 在代码层面对引用本身取址取到的是变量的地址，但是对指针取址取到的是指针变量本身的地址

**"引用"作为函数参数有哪些特点？**

> 当用引用作为函数的参数时，其效果和用指针作为函数参数的效果相当。当调用函数时，函数中的形参就会被当成实参变量或对象的一个别名来使用，也就是说此时<span style=color:red;background:yellow>**函数中对形参的各种操作实际上是对实参本身进行操作**</span>，而非简单的将实参变量或对象的值拷贝给形参。

**在什么时候需要使用"常引用"？**

> 在引用作为函数参数时，如果不希望在函数体中通过引用改变传入的参数，那么可以使用const引用作为函数参数。





第二题

**什么是函数重载？其实现原理是什么？如何进行C与C++的混合编程？**

> C++ 允许多个函数拥有相同的名字，只要它们的参数列表不同（参数的个数、类型、顺序有任意不同）就可以，这就是函数重载。借助重载，一个函数名可以有多种用途。
>
> 实现原理：当函数名称相同时 ，C++编译器会根据函数参数的类型、顺序、个数进行名字改编，将这些信息包含在新的函数名中，从而使得一系列重载的函数拥有不同的函数名。
>
> 使用extern "C"{}的方式，将C语言的部分放在大括号中，编译器将对其中的部分按C语言的方式进行编译。





第三题 

写结果

``` c++
#include <iostream>

using std::cout;
using std::endl;

//func2与func3均可以实现两个参数值的实际交换
void f2(int &x, int &y)
{
	int z = x;
	x = y;
	y = z;
}

void f3(int *x, int *y)
{
	int z = *x;
	*x = *y;
	*y = z;
}

int main()
{
	int x, y;
	x = 10; y = 26;
	cout << "x, y = " << x << ", " << y << endl; //10,26
	f2(x, y);                                    
	cout << "x, y = " << x << ", " << y << endl; //26,10
	f3(&x, &y);
	cout << "x, y = " << x << ", " << y << endl; //10,26
	x++; // x = 11， 表达式的值为10
	y--; // y = 25,  表达式的值为26
	f2(y, x);//完成值的交换，调用时顺序调换不影响实现效果
	cout << "x, y = " << x << ", " << y << endl; //25,11
	return 0;
}
```





第四题

写结果

``` c++
int foo(int x,int y)
{
	if(x <= 0 ||y <= 0){
        return 1;
    }
	return 3 * foo(x-1, y/2);
}

cout << foo(3,5) << endl;
```

> 第一次调用 3 * func(2,2)
>
> 第二次调用 3 * 3 * function(1,1)
>
> 第三次调用 3 * 3 * 3 * func(0,0) = 3 * 3 * 3 * 1 = 27





第五题

输入5的结果

``` c++
int main(int argc, char** argv)
{
	int x;
	cin >> x;
	if(x++ > 5)
	{
		cout << x << endl;
	}
	else
	{
		cout << x-- << endl;
	}

return 0;
}
```

> 输入5，x++表达式的值为5，x的值变为6，走else分支，进行x--，此表达式的值为6，x的值变为5，最终输出的是6



第六题

写结果

``` c++
#include <iostream>
using std::cout;
using std::endl;


void test1()
{
	int a[5]={1,2,3,4,5};
	cout << a + 1 << endl;
	cout << &a + 1<< endl;
	//int * p = &a + 1;//error
	int *ptr=(int *)(&a+1);
	printf("%d,%d",*(a+1),*(ptr-1));
}


int main(void){
    test1();
    return 0;
}
```

> &a获取到的实际是一个数组指针，&a + 1的操作是将指针偏移了整个数组的长度（20个字节），也就是偏移到元素5的地址后一位。
>
> 进行强制转换后，ptr是一个int*指针，ptr - 1 就会再向前偏移4个字节，来到元素5的位置，解引用后获取5
>
> 输出结果 2，5
>
> 
