---

类型: 笔记
创建日期: 2024-06-18
修改日期: 2024-06-18
---
## 实验目的
本次实验在 ROS 环境下使用基于话题（发布-订阅）的异步通信及基于服务（请求-应答）的同步通信两种通信方式，编写基本的应用程序，了解基于话题的通信与基于服务的通信区别以及应用场景。
## 实验内容
1. 编写基于话题通信的应用程序。
2. 编写基于服务通信的应用程序。
3. 阐述两种通信方式的区别及应用场景。
## 实验步骤
### 编写基于话题的异步通信应用程序
在工作空间中创建新的发布者`another_helloworld_publisher`
![[Pasted image 20240618001839.png]]
修改`another_helloworld_publisher`的编译依赖，项目名
![[Pasted image 20240618001855.png]]
![[Pasted image 20240618001930.png]]

修改发布频率，话题名称
将发布频率改为20，话题名称改为`helloworld from another publisher`
![[Pasted image 20240619001452.png]]
编译`another_helloworld_publisher`
![[Pasted image 20240618002148.png]]
同时运行两个发布者和一个接收者，可以看出接收者同时收到了两个发布者的消息。新的发布者的发送频率是原发布者的2倍，这在接收方的接收内容中也有所体现。
![[Pasted image 20240619001716.png]]
### 编写基于服务的同步通信应用程序
输入命令进入文档
```
sudo vim /opt/ros/melodic/share/genmsg/cmake/../../../lib/genmsg/gen
msg_check_deps.py
```
在 import sys 后加入以下代码方便进行包路径查找
```
sys.path.append("/opt/ros/melodic/lib/python2.7/dist-packages")
```
效果如图
![[Pasted image 20240619002503.png]]
编译文件并运行
可以看出在不带参数的执行中，使用的参数为 client.cpp 中定义的参数值，返回300
在rosservice call 命令调用带参数的服务，相当于用命令方式完成客户端发出请求的工作，返回结果正确。
![[Pasted image 20240619003012.png]]
## 实验分析
总结基于话题的异步通信与基于服务的同步通信两者之间的区别以及应用场景。
#### 基于话题的异步通信
**特点**:
1. **非阻塞**：发布者发布数据后，不等待订阅者的确认，立即进行后续任务。
2. **松耦合**：发布者和订阅者之间没有直接的联系，双方只需要关注同一个话题即可。
3. **多对多通信**：一个话题可以有多个发布者和多个订阅者。
**应用场景**:
1. **传感器数据发布**：如激光雷达、摄像头等传感器持续发布数据，不关心处理结果。
2. **状态广播**：如机器人位置、速度等状态信息，需要广播给多个模块。
3. **实时性要求高的场景**：数据需要快速发布，不适合等待响应的场景。

#### 基于服务的同步通信
**特点**:
1. **阻塞**：客户端发出请求后，会进入等待状态，直到服务端返回结果。
2. **紧耦合**：客户端和服务端之间存在直接的请求和响应关系。
3. **一对一通信**：每次请求对应一个服务提供者。
**应用场景**:
1. **命令执行**：如机器人执行特定命令（抓取、移动到指定位置等），需要确认执行结果。
2. **查询和应答**：如查询传感器状态、系统配置等，需要获取具体的反馈信息。
3. **事务处理**：需要确保某个操作完成后再进行下一步操作，如数据库操作。
### 总结
基于话题的异步通信适用于不需要等待响应的数据传输场景，强调数据的实时性和系统的松耦合。而基于服务的同步通信则适用于需要确认操作结果的场景，强调操作的确定性和系统的紧耦合。两者可以根据具体的应用需求互补使用，以实现系统的最佳性能和可靠性。