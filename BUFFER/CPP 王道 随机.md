---

类型: 笔记
创建日期: 2024-08-11
修改日期: 2024-08-11
---
const修饰的变量可以使用const_cast<T>(variable)转换为非const。

只有构造函数才有**初始化列表**，赋值运算符被调用时，左边的对象已经初始化好分配好内存了，没法有初始化列表。初始化列表里的元素就是初始化，函数体里的是赋值操作。

拷贝构造函数的参数一定是此类对象的引用而不是对象，因为如果函数参数是对象，本身就会调用拷贝构造给实参初始化成形参的样子，这样就无限递归了


用const左值引用指向字面量，直接被嵌入代码中了。
如果是字符串常量应该是在.rodata段
![[file_1723368100484_126.png]]
![[Pasted image 20240811172215.png]]

析构函数的作用不是回收对象本身的成员（而是去处理额外申请的资源等），因为对象的生命周期不是由析构函数决定的，站上对象的生命周期是由函数调用栈决定的。分清楚**初始化**和**赋值**

const对象无法调用非const成员函数，非const就是代表要改变，即使代码逻辑不改变。

const成员函数不能修改对象中的指针指向，但是能修改指针指向元素的值。

析构函数是私有的话，就不能在栈上创建对象，因为无法在外部调用析构函数。
