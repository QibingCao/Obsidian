JMM是java的内存模型，是一个抽象的规范，是用来解决java多线程程序运行中会出现的问题的一种建模。
JMM是无法和JVM中的内存概念一一对应的，是多对多的关系，也可以说JVM内存管理是一套符合JMM规范的实现方式。
## JMM
JMM中有主内存和工作内存。主内存就是共享的全局的内存，工作内存是线程私有的，工作内存中有共享变量的本地副本。当一个线程要去访问或修改共享内存的数据，他会先访问共享内存，拷入本地内存后进行修改，然后再拷回主内存。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/2699722/1710747660590-32a97c65-5223-4e39-b996-02a5ee0a2e00.png#averageHue=%23ebf4e8&clientId=u10b00272-8c12-4&from=paste&height=381&id=u3b19377d&originHeight=1010&originWidth=1273&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=964866&status=done&style=none&taskId=u22afec3e-79c3-4c9e-879b-d830dc96329&title=&width=480.77459716796875)
## 硬件内存架构 OS 和 java多线程的关系
java的多线程不论哪种构建方式，最终还是会new一个Thread对象，并调用start方法。
 `new Thread( Runnable ).start();` 

![image.png](https://cdn.nlark.com/yuque/0/2024/png/2699722/1710747968234-587d0e13-ec1e-41d2-8bdb-dbaa68fa18a3.png#averageHue=%23eff6e7&clientId=u10b00272-8c12-4&from=paste&height=561&id=ufb7f790f&originHeight=1292&originWidth=1028&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=881349&status=done&style=none&taskId=uc0149be4-b4d4-40f2-bf98-507626514a7&title=&width=446.0264892578125)
线程是OS调度的最小单位，java里的线程（语言层面）最终也会被OS映射到在硬件上运行的不同线程。Java中的线程和内核线程一一对应。
### 多线程的三大特性
#### 原子性
类似事务的原子性，程序执行是一体的，要么成功，要么失败，不会被中途打断。
#### 可见性
当某线程对共享的数据修改后，其余线程也应当立即得知此消息。
#### 有序性
同一线程的代码应当是串行一条一条执行的。
##### 指令重排
此处要说明指令重排，重排是在单线程下保证串行语义不发生改变，通过改变指令执行顺序，让程序更有效率。
编译器优化重排 -> 指令并行重排 -> 内存系统重排
编译器重排：编译器会在编译代码时，更改代码顺序。
指令并行重排：cpu流水线处理指令，会改变一定顺序。
内存系统重排
## Volatile关键字
volatile关键字会禁止编译器层面的重排，以及底层指令的重排。
在底层指令中间插入load/store屏障，屏障前后的代码就不会被重新排序。
当写一个volatile变量时，JMM会把该线程工作内存中的共享变量值刷新到主内存中；
当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，那么该线程只能从主内存中重新读取共享变量。
多核处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据，来检查自己寄存器中的值是不是过期了，当处理器发现自己寄存器中对应内存地址的数据被修改时，就会将当前处理器的缓存行设置成无效状态，当处理器对这个无效状态的数据进行修改时，就会重新从机器内存中读取数据到CPU寄存器
### 可以保证**可见性**和**顺序性，不保证原子性**
通过内存屏障可以保证程序的可见性和顺序性。
但是无法保证原子性。
假设两个线程被绑定在不同cpu核心上，同时执行修改命令并同时提交，此时就会出现写覆盖的问题。破坏了原子性。
<!--SR:!2024-04-03,3,250!2024-04-03,3,250-->


