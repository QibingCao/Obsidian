# 存储引擎
![image.png](https://cdn.nlark.com/yuque/0/2024/png/2699722/1709088740345-765954b7-be80-409a-9a3a-4929a2dfd00d.png#averageHue=%23e1d8d2&clientId=u6fee383d-038f-4&from=paste&height=423&id=u1454e097&originHeight=634&originWidth=1185&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=286054&status=done&style=none&taskId=u1e6bc1f5-3180-4eeb-aa6c-0f7b644cd78&title=&width=790)
index在引擎层，不同引擎有着不同的索引设计方式。

MySQL中只有InnoDB支持事务。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/2699722/1709726274776-6b5c8f75-6efe-4c33-85cf-9d8c82d54d5f.png#averageHue=%23fcfcfb&clientId=ucca97d74-531f-4&from=paste&height=328&id=u55358620&originHeight=615&originWidth=779&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=52078&status=done&style=none&taskId=ueed86dd1-d6a6-4060-a8de-475089ec40e&title=&width=415.46666666666664)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/2699722/1709726391750-f3907306-5797-461f-b447-ee69bbaf3dd6.png#averageHue=%23f9f8e8&clientId=ucca97d74-531f-4&from=paste&height=137&id=u36f852ad&originHeight=256&originWidth=769&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=113900&status=done&style=none&taskId=u27a426b7-d4ea-4be7-bc30-dcc0b771cb5&title=&width=410.1333333333333)
## 索引
### 为什么用B+树而不是B树？
#### 1. 磁盘I/O优化

- **B+树的磁盘读写效率更高**：在B+树中，所有的数据都存储在叶子节点，且叶子节点之间是通过指针连接的。在进行范围查询时，能够通过一次磁盘读操作后，仅通过指针遍历就可以获取到全部的数据，大大减少了磁盘I/O操作。
- **B树每个节点存储键值对**：相比之下，B树的每个节点都可以存储数据，这意味着范围查询可能需要多次从磁盘中读取不连续存储的节点，增加了磁盘I/O成本。
#### 2. 空间利用率
<!--SR:!2024-04-03,3,250!2024-04-03,3,250-->

- **B+树具有更高的空间利用率**：由于B+树的内部节点可以存储更多的键。这意味着对于相同的磁盘空间，B+树可以拥有更宽的宽度，从而减少树的深度，优化查询效率。
- **B树的内部节点存储数据**：这限制了节点可以持有键的数量，导致树可能更深，增加了查询时的磁盘I/O次数。
#### 3. 查询性能
<!--SR:!2024-04-03,3,250!2024-04-03,3,250-->

- **B+树提供了更加稳定的查询性能**：由于所有的数据都存储在叶子节点，并且叶子节点是顺序链接的，因此范围查询和顺序访问变得非常高效。这对于需要大量范围查询的数据库应用来说，是一个显著的优势。
- **B树在处理范围查询时效率较低**：因为数据分布在整个树中，需要遍历更多的节点来完成同样的查询。
#### 4. 更新操作的优化
<!--SR:!2024-04-03,3,250!2024-04-03,3,250-->

- **B+树在更新操作时性能更稳定**：在B+树中，所有数据记录都在叶子节点，在进行插入和删除操作时，只影响到叶子节点及其路径上的节点，更容易维护数据的物理顺序。
- **B树的更新可能影响更多的节点**：因为数据不仅分布在叶子节点，更新操作可能会导致更多级别的节点分裂或合并，增加了更新的复杂度。
<!--SR:!2024-04-03,3,250!2024-04-03,3,250-->



### 聚集索引选取规则
如果存在主键，主键索引就是聚集索引。
如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。 
如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。

主键使用自增ID，所有新插入的数据都会放到最后。不然非自增ID做主键，插入时会频繁移动后续元素。
### 二级索引(非聚集索引)和聚集索引
聚集索引叶子节点存储具体的物理地址，二级索引仅存储键值和指向聚集索引键的指针。
使用二级索引只能查询到数据在聚集索引键中的值，再根据值去聚集索引中查询真正的物理地址。
->**回表查询**。
### 最左前缀原则
在联合索引中，多个列合并为一个索引键，并按照这个组合键的顺序存储。例如，对于**INDEX(col1, col2, col3)**，索引项首先按**col1**排序，**col1**相同的情况下按**col2**排序，依此类推。
最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是
第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。
只要最左边的字段存在就会使用索引，索引能使用几个字段取决于联合索引后面的字段是否存在。
### 索引失效
#### 范围查询右侧的字段索引会失效
进行范围查询（如**col1**在某个范围内）后，数据库需要扫描所有满足该范围条件的记录。这时，对于**col1**之后的列（如**col2**、**col3**等），数据库无法直接利用索引跳转到特定的值，因为这些值分布在**col1**满足条件的整个范围内。
在使用 **>=** 或 **<=** 对联合索引的第一列进行查询时，如果紧接着的条件是针对索引中的后续列，并且使用的是等值查询（**=**），MySQL会尽可能地利用索引。然而，这种情况下的索引利用效率通常低于仅包含等值查询条件的情况。（是因为等于号才能使用到索引，没有等于号只能线性扫描？）
#### 对字段进行函数运算会失效
#### 查询语句中字符串不加单引号失效
存在隐式的类型转换，失效
#### 模糊匹配头部，索引失效
### 索引使用
#### or连接的查询字段，只有均有索引时才会使用索引。
#### 如果MySQL评估走索引比顺序慢，则不走索引。
#### SQL提示
use index(...) / ignore index(...) / force index(...)
#### 覆盖索引
尽量不要用*，select索引中有的字段。
考虑二级索引的存储方式，节点中都存着什么数据。若查询主键和索引以外的数据需要回表。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/2699722/1709734047968-569a3c3d-5713-4123-b26c-62732ec0adef.png#averageHue=%23eadb0c&clientId=u10c2f706-19e4-4&from=paste&height=39&id=u6f22f1ce&originHeight=74&originWidth=1173&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=105393&status=done&style=none&taskId=u9884fb3f-885b-4adf-a5cc-561888df30d&title=&width=625.6)
#### 前缀索引
对于字符串，取前i位建立索引以节省空间，减少磁盘IO。
```sql
// distinct 可以保证不重复
select count(distinct substring(email,1,5)) / count(*) from tb_user ;
```
#### 单列索引和联合索引
查询时有多个查询条件，建议使用覆盖的联合索引，不用回表查询。
### 索引设计原则
1. 针对于数据量较大，且查询比较频繁的表建立索引。
2. 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。
3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
4. 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
	create unique index idx_user_phone_name on tb_user(phone,name);
7. 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。
<!--SR:!2024-04-03,3,250!2024-04-03,3,250!2024-04-03,3,250!2024-04-03,3,250!2024-04-03,3,250!2024-04-03,3,250!2024-04-03,3,250!2024-04-03,3,250!2024-04-03,3,250!2024-04-03,3,250!2024-04-03,3,250!2024-04-03,3,250!2024-04-03,3,250-->

## SQL优化
### 插入数据

### 视图
#### cascaded or local
在使用**WITH CHECK OPTION**时，可以指定它是**CASCADING**还是**LOCAL**：
<!--SR:!2024-04-03,3,250!2024-04-03,3,250!2024-04-03,3,250-->

- **CASCADING**: 当设置为**CASCADING**时，**WITH CHECK OPTION**将确保所有级联的视图和视图更新（包括视图基于的其他视图）都遵守定义在最顶层视图上的条件约束。这意味着，如果有多层视图（一个视图基于另一个视图），则任何对顶层视图的更新将会检查所有底层视图定义的约束，以确保更新不会导致这些视图的定义条件被违反。
- **LOCAL**: 当设置为**LOCAL**时，**WITH CHECK OPTION**只确保直接对该视图进行的更新操作不会使视图定义的条件失效。它不考虑任何基于该视图的其他视图的约束。也就是说，该选项只在当前视图层面上检查约束条件，不会检查任何从这个视图派生的其他视图的条件。
<!--SR:!2024-04-03,3,250!2024-04-03,3,250!2024-04-03,3,250!2024-04-03,3,250!2024-04-03,3,250!2024-04-03,3,250-->

简而言之，**CASCADING**选项提供了一种方式来确保所有相关视图的约束条件都得到遵守，而**LOCAL**选项则仅确保对当前视图的直接更新不违反其定义条件。
<!--SR:!2024-04-03,3,250!2024-04-03,3,250-->

# 锁
按粒度分，全局锁，表级锁，行级锁。
## 全局锁
对整个数据库实例加锁，数据库处于只读状态。DML，DDL，修改事务提交均被阻塞。
可用于做全局的==逻辑备份==，保证数据一致性consistency。
## 表级锁
### 表锁
lock tables 表1，表2   read/write
unlock tables
#### 表共享读锁 read lock
阻塞所有写操作，不阻塞读。
#### 表独占写锁 write lock
阻塞其他进程所有操作，自己可读写。
### 元数据锁 Meta Data Lock
元数据锁可以简单理解为表结构锁，为了防止DML，DDL冲突。元数据锁系统自动，无需显式调用。增删改查时，自动对表加MDL读锁（共享锁）；修改表结构时，自动加MDL写锁（排他锁）。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/2699722/1709814798382-bc110815-97c9-43e8-ad6f-ba38f2bb5c78.png#averageHue=%23fcfcfa&clientId=ubc229386-b06b-4&from=paste&height=261&id=uf25f3792&originHeight=682&originWidth=1131&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=83947&status=done&style=none&taskId=u9b430c9c-8060-48ce-9768-097888bc4da&title=&width=433.20001220703125)
### 意向锁
##### 意向共享锁 IS 意向排他锁 IX
【此处的S， X锁为行级锁】
<!--SR:!2024-04-03,3,250-->

- 共享锁（S锁）与其他共享锁（S锁）是兼容的。
- 排他锁（X锁）与其他锁类型都不兼容。
- 意向共享锁（IS锁）与意向共享锁（IS锁）和意向排他锁（IX锁）是兼容的。
- 意向排他锁（IX锁）与意向共享锁（IS锁）和意向排他锁（IX锁）是兼容的。

意向锁的主要目的是为了在表级别上快速检查是否存在潜在的行级锁冲突，从而避免不必要的行级锁检查。
###### 意向锁的工作机制是这样的：

- 当事务想要对某个数据行加**共享锁**时，它会自动在对应的表上加一个**意向共享锁（IS锁）**。
- 当事务想要对某个数据行加**排他锁**时，它会自动在对应的表上加一个**意向排他锁（IX锁）**。
###### 意向锁的目的：
<!--SR:!2024-04-03,3,250!2024-04-03,3,250!2024-04-03,3,250!2024-04-03,3,250-->

- **兼容性检查**：意向锁使得数据库在表级别就能快速判断是否存在锁冲突，而无需检查表中每一行的锁情况，从而提高效率。
- **锁升级的可能性**：如果一个事务对表中的多个行加了行级锁，然后需要对整个表加锁，数据库可以通过检查表级别的意向锁来快速决定是否能够升级锁。
###### 实践中的意义：
在实践中，你不需要显式地去请求意向锁。当你对数据行请求S锁或X锁时，MySQL自动处理意向锁的请求和释放。意向锁的存在主要是为了内部锁调度的需要，以及提高并发事务处理的性能，而不是需要用户直接干预的锁类型。
## 行级锁
InnoDB数据是基于索引组织的，行锁是通过对索引项加锁实现的。
<!--SR:!2024-04-03,3,250!2024-04-03,3,250-->

