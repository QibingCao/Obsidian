# 39
充分利用递归，边界条件仅用总和判断即可。
由于数字可以使用多次，进入下一层时当前下标不需要+1。
```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    List<Integer> cur = new LinkedList<>();
    int curSum = 0;

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        backTracking(candidates, target, 0);
        return res;
    }

    private void backTracking(int[] candidates, int target, int curIndex){
        if(curSum > target) return;
        
        if(curSum == target){
            res.add(new LinkedList<>(cur));
            return;
        }
        
        for(int i = curIndex; i < candidates.length; i++){
            // Add current candidate
            cur.add(candidates[i]);
            curSum += candidates[i];
            
            // Recursive call allowing to reuse the same index
            backTracking(candidates, target, i);
            
            // Backtrack
            cur.remove(cur.size() - 1);
            curSum -= candidates[i];
        }
    }
}

```

# 40
元素有重复，要保证结果的组合不重复
### 要点
升序排列元素，此时相同元素必相邻。
相同的元素可能出现在同一棵树中，或者同一层。由于我们默认递归curIndex为i+1，不会出现同一个元素被重复使用，在同一棵树中的相同元素不是同一个。
要保证组合结果不重复，实际要求在同一层的递归中（横向for循环中），不能使用相同的元素（一个值只能用一次）。对同一棵树中的元素没要求。
此时创建一个boolean数组记录每个元素是否被当前树上的节点正在使用，如果在当前元素之前的相同元素被访问，说明在同一棵树中，不要紧；若相同元素没正被访问，那说明这层已经处理过这个元素的情况了，需要直接去找下一个值。

