# 2.58 
> 编写过程 is_little_endian当在小端法机器上编译和运行时返回 1，在大端法机器上编译运行时则返回 0。这个程序应该可以运行在任何机器上，无论机器的字长是多少。

声明一个int型变量，给它的最低有效字节赋值。取它的第一个字节的数据，如果被赋值为小端法，否则大端法。
```c
typedef unsigned char* byte_pointer;
int is_little_endian(){
    int test = 0xff;
    byte_pointer p = (byte_pointer)& test;
    if(p[0]==0xff)
        return 1;
    else
        return 0;    
}
```
# 2.61
> 写一个 C 表达式，在下列描述的条件下产生 1，而在其他情况下得到 0。假设 x是 int类型。 
> A.x的任何位都等于 1。 

`!~ x`
> B. x的任何位都等于 0。 

`! x`
> C. x的最低有效字节中的位都等于 1。 

`!~ (x | ~0xff)`
> D. x的最高有效字节中的位都等于 0。 

`!~ (x | 0xffffff)`
> 代码应该遵循位级整数编码规则，另外还有一个限制，你不能使用相等（==)和不相等（！=) 测试。


# 2.77
> 假设我们有一个任务：生成一段代码，将整数变量**x**乘以不同的常数因子 K。为了提高效率，我 们想只使用+、-、和 << 运算。对于下列 **K** 的值，写出执行乘法运算的 **C**表达式，每个表达式中 最多使用 3 个运算。
> A. K=17
<!--SR:!2024-04-15,15,270!2024-04-16,16,270!2024-04-13,13,270-->

`(x << 4) + x`
> B. K=-7 

`x - (x << 3)`
> C. K=60 

`(x << 6) - (x << 2)`
> D. K=-112

`(x << 4) - (x << 7)`
# 2.84
> 填写下列程序的返回值，这个程序测试它的第一个参数是否小于或者等于第二个参数。假定函数 f2u 返回一个无符号 32 位数字，其位表示与它的浮点参数相同。你可以假设两个参数都不是 NaN。 两种 0，+0 和-0 被认为是相等的。 

```c
int float_le(float x, float y){ 
    unsigned ux = f2u(x); 
    unsigned uy = f2u(y); 
    
    /* Get the sign bits */ 
    unsigned sx = ux » 31; 
    unsigned sy = uy » 31; 
    /* Give an expression using only ux, uy, sx, and sy */

    return (ux<<1==0&&uy<<1==0)||  // 均为0
            (sx&&!sy)||            // 左负右正
            (!sx&&!sy&&ux<=uy)||   // 均正，左值不大于右值
            (sx&&sy&&ux>=uy);      // 均负，右值不大于左值
}
```
# 2.89
> 我们在一个 **int**类型为 **32**位补码表示的机器上运行程序。**float**类型的值使用**32**位 **IEEE**格式， 而 **double**类型的值使用 **64**位 **IEEE**格式。
> 我们产生随机整数 x, y和 z 并且把它们转换成 **double**类型的值：
<!--SR:!2024-04-12,12,270!2024-04-14,14,270!2024-04-15,15,270!2024-04-16,16,270!2024-04-13,13,270!2024-04-12,12,270!2024-04-14,14,270!2024-04-15,15,270!2024-04-16,16,270!2024-04-13,13,270-->

```c
/* Create arbitrary values */ 
int x = random(); 
int y = random(); 
int z = random(); 
/* Convert to double */ 
double dx = (double) x; 
double dy = (double) y; 
double dz = (double) z; 
```
> 对于下列的每个 **C**表达式，你要指出表达式是否总是为 1。如果它总是为 1，描述其中的数学原理。否则，列举出使它为 0 的参数的例子。请注意，不能使用 IA32 机器运行 **GCC**来测试你的 答案，因为对于 **float**和 **double**它使用的都是 80 位的扩展精度表示。
> A. (float)x==(float)dx
<!--SR:!2024-04-12,12,270!2024-04-14,14,270!2024-04-15,15,270!2024-04-16,16,270--> 

是，double涵盖了float能表示的范围
> B. dx-dy==(double)(x-y) 

否，x为INT_MAX, y为INT_MIN
> C. (dx+dy)+dz==dx+(dy+dz) 

是，int转换为double不会有精度上的损失
> D.(dx*dy)*dz==dx*(dy*dz) 

否，dx与dy互为倒数且dy * dz = +infinite
> E.dx/dx==dz/dz

否，z==0
# 2.91
> A. 这个浮点值表示的二进制小数是多少？

11.0010010000111111011011
> B. 22/7的二进制小数表示是什么？ 

11.001001`001循环`
> C.这两个 pai 的近似值从哪一位（相对于二进制小数点）开始不同的？

从第9位开始不同
