上节课是基于图着色的寄存器分配，见ppt，没写笔记。

语言不会对变量的数量做约束，所以你可以在一个函数中声明无限多的变量，但是寄存器的数量是有限的。
变量的生存周期 <= 函数调用本身

最优化问题，如何将这么多变量塞入寄存器之中？最优化问题（二次往上）本身是NPC的（不可判定问题）。
好多问题抽象出来都是数学问题。

将问题抽象成干涉图的图着色。
实现难点，数据结构相当复杂，运行时间复杂度没有保障（发现分配不成功之后中心来过）


#### 指令选择
之前应该已经讲过了？gcc是宏展开，相当于源代码映射几条汇编，这要求源代码的粒度要大于汇编。

然后进行寄存器分配，再用窥孔优化，优化掉不必要的汇编代码mov r，r。

活性分析？

## 线性扫描 Linear Scan
不需要迭代，一遍完成。

很年轻，1999。图着色1879，写出算法花了差不多一百年。

如果很在意编译速度，就提倡用线性扫描。JIT就是采用线性扫描。


核心概念，活跃区间（live interval）
[from , to] 从定义点def，到他的使用点use

```

    1
1:  =
    a


     a+b
5:   =
	 e

```  
所以e和a没有交集。

从头到尾顺序扫描，这tm不就是最大重叠区间问题么



但控制流图本身是一个流结构，理论上有多少分支就可能会有多少个活跃区间。

拓扑序，或者逆先序遍历序，逆深度优先序（为什么不是逆广度优先序）
这样做就会把原来的活跃区间拉长了。tradeoff


### 接合



后面PPT


# 垃圾回收
说法1：malloc，new比GC快
说法2：GC会导致程序卡顿
说法3：垃圾回收没有办法处理大内存
说法4：我们国家能自研垃圾回收器吗

## 堆分配 Heap Allocation
栈不需要垃圾回收，栈帧有自己的生命周期。

lab中new A()回调用Tiger_New
如果不回收内存，就会导致内存泄漏。

两种措施
C/CPP 手工free（所有的内存问题都来自手工管理堆）
GC 任何现代语言，自动


垃圾：
	语法垃圾：没被根指向的
	语义垃圾：没被使用的（从算法理论来说，是不可判定的）

我们都是优化第一类，所以GC还是会有第二类的泄露。



Java 多线程全局暂停收集
多个线程都在访问堆。必须是所有的线程都暂停才能安全的GC。

**我们是在分配的时候不够了才GC**
回溯栈帧，重建现场，然后扫描堆。照片中的L_1向量这种
有的线程就是死循环不出来，访问堆中的对象，还不分配。要在循环之前主动check。
见黑板照片


- 标记清除
- 引用计数
- 拷贝收集 from to半堆，从root出发，到的都拷贝
- 世代收集 
	- 大多数对象都die young
	- 大部分年轻一代指向老一代

